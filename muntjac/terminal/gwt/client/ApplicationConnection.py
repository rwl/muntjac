# Copyright (C) 2011 Vaadin Ltd
# Copyright (C) 2011 Richard Lincoln
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

from __pyjamas__ import (ARGERROR,)
from com.vaadin.terminal.gwt.client.ComponentLocator import (ComponentLocator,)
from com.vaadin.terminal.gwt.client.ApplicationConfiguration import (ApplicationConfiguration,)
from com.vaadin.terminal.gwt.client.RenderSpace import (RenderSpace,)
from com.vaadin.terminal.gwt.client.LocaleService import (LocaleService,)
from com.vaadin.terminal.gwt.client.ui.VNotification import (EventListener, VNotification,)
from com.vaadin.terminal.gwt.client.BrowserInfo import (BrowserInfo,)
from com.vaadin.terminal.gwt.client.SynchronousXHR import (SynchronousXHR,)
from com.vaadin.terminal.gwt.client.Util import (Util,)
from com.vaadin.terminal.gwt.client.ui.dd.VDragAndDropManager import (VDragAndDropManager,)
from com.vaadin.terminal.gwt.client.RenderInformation import (FloatSize, Size,)
from com.vaadin.terminal.gwt.client.VTooltip import (VTooltip,)
from com.vaadin.terminal.gwt.client.ui.VContextMenu import (VContextMenu,)
from com.vaadin.terminal.gwt.client.VConsole import (VConsole,)
from com.vaadin.terminal.gwt.client.ui.VView import (VView,)
# from com.google.gwt.core.client.GWT import (GWT,)
# from com.google.gwt.core.client.JavaScriptObject import (JavaScriptObject,)
# from com.google.gwt.core.client.JsArray import (JsArray,)
# from com.google.gwt.core.client.JsArrayString import (JsArrayString,)
# from com.google.gwt.core.client.Scheduler import (Scheduler,)
# from com.google.gwt.http.client.Request import (Request,)
# from com.google.gwt.http.client.RequestBuilder import (RequestBuilder,)
# from com.google.gwt.http.client.RequestCallback import (RequestCallback,)
# from com.google.gwt.http.client.RequestException import (RequestException,)
# from com.google.gwt.http.client.Response import (Response,)
# from com.google.gwt.user.client.Command import (Command,)
# from com.google.gwt.user.client.DOM import (DOM,)
# from com.google.gwt.user.client.Element import (Element,)
# from com.google.gwt.user.client.Event import (Event,)
# from com.google.gwt.user.client.History import (History,)
# from com.google.gwt.user.client.Timer import (Timer,)
# from com.google.gwt.user.client.Window import (Window,)
# from com.google.gwt.user.client.ui.FocusWidget import (FocusWidget,)
# from com.google.gwt.user.client.ui.Focusable import (Focusable,)
# from com.google.gwt.user.client.ui.HasWidgets import (HasWidgets,)
# from com.google.gwt.user.client.ui.Widget import (Widget,)
# from com.vaadin.terminal.gwt.client.RenderInformation.FloatSize import (FloatSize,)
# from com.vaadin.terminal.gwt.client.RenderInformation.Size import (Size,)
# from com.vaadin.terminal.gwt.client.ui.VNotification.HideEvent import (HideEvent,)
# from java.util.ArrayList import (ArrayList,)
# from java.util.Date import (Date,)
# from java.util.HashMap import (HashMap,)
# from java.util.HashSet import (HashSet,)
# from java.util.Iterator import (Iterator,)
# from java.util.Map import (Map,)
# from java.util.Set import (Set,)


class ApplicationConnection(object):
    """This is the client side communication "engine", managing client-server
    communication with its server side counterpart
    {@link AbstractCommunicationManager}.

    Client-side widgets receive updates from the corresponding server-side
    components as calls to
    {@link Paintable#updateFromUIDL(UIDL, ApplicationConnection)} (not to be
    confused with the server side interface {@link com.vaadin.terminal.Paintable}
    ). Any client-side changes (typically resulting from user actions) are sent
    back to the server as variable changes (see {@link #updateVariable()}).

    TODO document better

    Entry point classes (widgetsets) define <code>onModuleLoad()</code>.
    """
    # This indicates the whole page is generated by us (not embedded)
    GENERATED_BODY_CLASSNAME = 'v-generated-body'
    _MODIFIED_CLASSNAME = 'v-modified'
    _REQUIRED_CLASSNAME_EXT = '-required'
    _ERROR_CLASSNAME_EXT = '-error'
    VAR_RECORD_SEPARATOR = '\u001e'
    VAR_FIELD_SEPARATOR = '\u001f'
    VAR_BURST_SEPARATOR = '\u001d'
    VAR_ARRAYITEM_SEPARATOR = '\u001c'
    UIDL_SECURITY_TOKEN_ID = 'Vaadin-Security-Key'
    # @deprecated use UIDL_SECURITY_TOKEN_ID instead
    UIDL_SECURITY_HEADER = UIDL_SECURITY_TOKEN_ID
    PARAM_UNLOADBURST = 'onunloadburst'
    ATTRIBUTE_DESCRIPTION = 'description'
    ATTRIBUTE_ERROR = 'error'
    # will hold the UIDL security key (for XSS protection) once received
    _uidlSecurityKey = 'init'
    _resourcesMap = dict()
    _pendingVariables = list()
    _idToPaintableDetail = ComponentDetailMap.create()
    _widgetSet = None
    _contextMenu = None
    _loadTimer = None
    _loadTimer2 = None
    _loadTimer3 = None
    _loadElement = None
    _view = None
    applicationRunning = False
    _activeRequests = 0
    # Parameters for this application connection loaded from the web-page
    _configuration = None
    # List of pending variable change bursts that must be submitted in order
    _pendingVariableBursts = list()
    # Timer for automatic refirect to SessionExpiredURL
    _redirectTimer = None
    # redirectTimer scheduling interval in seconds
    _sessionExpirationInterval = None
    _relativeSizeChanges = list()
    _componentCaptionSizeChanges = list()
    _requestStartTime = None
    _validatingLayouts = False
    _zeroWidthComponents = None
    _zeroHeightComponents = None
    _unregistryBag = set()

    def __init__(self):
        self._tooltip = VTooltip(self)
        self._view = GWT.create(VView)

    def init(self, widgetSet, cnf):
        VConsole.log('Starting application ' + cnf.getRootPanelId())
        VConsole.log('Vaadin application servlet version: ' + cnf.getServletVersion())
        VConsole.log('Application version: ' + cnf.getApplicationVersion())
        if not (cnf.getServletVersion() == ApplicationConfiguration.VERSION):
            VConsole.error('Warning: your widget set seems to be built with a different ' + 'version than the one used on server. Unexpected ' + 'behavior may occur.')
        self._widgetSet = widgetSet
        self._configuration = cnf
        self._windowName = self._configuration.getInitialWindowName()
        componentLocator = ComponentLocator(self)
        appRootPanelName = cnf.getRootPanelId()
        # remove the end (window name) of autogenerated rootpanel id
        appRootPanelName = appRootPanelName.replaceFirst('-\\d+$', '')
        self.initializeTestbenchHooks(componentLocator, appRootPanelName)
        self.initializeClientHooks()
        self._view.init(cnf.getRootPanelId(), self)
        self.showLoadingIndicator()

    def start(self):
        """Starts this application. Don't call this method directly - it's called by
        {@link ApplicationConfiguration#startNextApplication()}, which should be
        called once this application has started (first response received) or
        failed to start. This ensures that the applications are started in order,
        to avoid session-id problems.

        @return
        """
        self.repaintAll()

    def initializeTestbenchHooks(self, componentLocator, TTAppId):
        # -{
        #     	var ap = this;
        #     	var client = {};
        #     	client.isActive = function() {
        #     		return ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::hasActiveRequest()()
        #     				|| ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::isExecutingDeferredCommands()();
        #     	}
        #     	var vi = ap.@com.vaadin.terminal.gwt.client.ApplicationConnection::getVersionInfo()();
        #     	if (vi) {
        #     		client.getVersionInfo = function() {
        #     			return vi;
        #     		}
        #     	}
        # 
        #     	client.getElementByPath = function(id) {
        #     		return componentLocator.@com.vaadin.terminal.gwt.client.ComponentLocator::getElementByPath(Ljava/lang/String;)(id);
        #     	}
        #     	client.getPathForElement = function(element) {
        #     		return componentLocator.@com.vaadin.terminal.gwt.client.ComponentLocator::getPathForElement(Lcom/google/gwt/user/client/Element;)(element);
        #     	}
        # 
        #     	if (!$wnd.vaadin.clients) {
        #     		$wnd.vaadin.clients = {};
        #     	}
        # 
        #     	$wnd.vaadin.clients[TTAppId] = client;
        #     }-

        pass

    def getVersionInfo(self):
        """Helper for tt initialization"""
        return self._configuration.getVersionInfoJSObject()

    def initializeClientHooks(self):
        """Publishes a JavaScript API for mash-up applications.
        <ul>
        <li><code>vaadin.forceSync()</code> sends pending variable changes, in
        effect synchronizing the server and client state. This is done for all
        applications on host page.</li>
        <li><code>vaadin.postRequestHooks</code> is a map of functions which gets
        called after each XHR made by vaadin application. Note, that it is
        attaching js functions responsibility to create the variable like this:

        <code><pre>
        if(!vaadin.postRequestHooks) {vaadin.postRequestHooks = new Object();}
        postRequestHooks.myHook = function(appId) {
                 if(appId == "MyAppOfInterest") {
                         // do the staff you need on xhr activity
                 }
        }
        </pre></code> First parameter passed to these functions is the identifier
        of Vaadin application that made the request.
        </ul>

        TODO make this multi-app aware
        """
        # -{
        #     	var app = this;
        #     	var oldSync;
        #     	if ($wnd.vaadin.forceSync) {
        #     		oldSync = $wnd.vaadin.forceSync;
        #     	}
        #     	$wnd.vaadin.forceSync = function() {
        #     		if (oldSync) {
        #     			oldSync();
        #     		}
        #     		app.@com.vaadin.terminal.gwt.client.ApplicationConnection::sendPendingVariableChanges()();
        #     	}
        #     	var oldForceLayout;
        #     	if ($wnd.vaadin.forceLayout) {
        #     		oldForceLayout = $wnd.vaadin.forceLayout;
        #     	}
        #     	$wnd.vaadin.forceLayout = function() {
        #     		if (oldForceLayout) {
        #     			oldForceLayout();
        #     		}
        #     		app.@com.vaadin.terminal.gwt.client.ApplicationConnection::forceLayout()();
        #     	}
        #     }-

        pass

    @classmethod
    def runPostRequestHooks(cls, appId):
        """Runs possibly registered client side post request hooks. This is expected
        to be run after each uidl request made by Vaadin application.

        @param appId
        """
        # -{
        #     	if ($wnd.vaadin.postRequestHooks) {
        #     		for ( var hook in $wnd.vaadin.postRequestHooks) {
        #     			if (typeof ($wnd.vaadin.postRequestHooks[hook]) == "function") {
        #     				try {
        #     					$wnd.vaadin.postRequestHooks[hook](appId);
        #     				} catch (e) {
        #     				}
        #     			}
        #     		}
        #     	}
        #     }-

        pass

    @classmethod
    def getConsole(cls):
        """Get the active Console for writing debug messages. May return an actual
        logging console, or the NullConsole if debugging is not turned on.

        @deprecated Developers should use {@link VConsole} since 6.4.5

        @return the active Console
        """
        return VConsole.getImplementation()

    @classmethod
    def isDebugMode(cls):
        """Checks if client side is in debug mode. Practically this is invoked by
        adding ?debug parameter to URI.

        @deprecated use ApplicationConfiguration isDebugMode instead.

        @return true if client side is currently been debugged
        """
        return ApplicationConfiguration.isDebugMode()

    def getAppUri(self):
        """Gets the application base URI. Using this other than as the download
        action URI can cause problems in Portlet 2.0 deployments.

        @return application base URI
        """
        return self._configuration.getApplicationUri()

    def hasActiveRequest(self):
        """Indicates whether or not there are currently active UIDL requests. Used
        internally to squence requests properly, seldom needed in Widgets.

        @return true if there are active requests
        """
        return self._activeRequests > 0

    def getRepaintAllParameters(self):
        # collect some client side data that will be sent to server on
        # initial uidl request
        clientHeight = Window.getClientHeight()
        clientWidth = Window.getClientWidth()
        pe = self._view.getElement().getParentElement()
        offsetHeight = pe.getOffsetHeight()
        offsetWidth = pe.getOffsetWidth()
        screenWidth = BrowserInfo.get().getScreenWidth()
        screenHeight = BrowserInfo.get().getScreenHeight()
        tzOffset = BrowserInfo.get().getTimezoneOffset()
        rtzOffset = BrowserInfo.get().getRawTimezoneOffset()
        dstDiff = BrowserInfo.get().getDSTSavings()
        dstInEffect = BrowserInfo.get().isDSTInEffect()
        curDate = BrowserInfo.get().getCurrentDate().getTime()
        widgetsetVersion = ApplicationConfiguration.VERSION
        token = History.getToken()
        # TODO figure out how client and view size could be used better on
        # server. screen size can be accessed via Browser object, but other
        # values currently only via transaction listener.
        parameters = 'repaintAll=1&' + 'sh=' + screenHeight + '&sw=' + screenWidth + '&cw=' + clientWidth + '&ch=' + clientHeight + '&vw=' + offsetWidth + '&vh=' + offsetHeight + '&fr=' + token + '&tzo=' + tzOffset + '&rtzo=' + rtzOffset + '&dstd=' + dstDiff + '&dston=' + dstInEffect + '&curdate=' + curDate + '&wsver=' + widgetsetVersion + ('&td=1' if BrowserInfo.get().isTouchDevice() else '')
        return parameters

    def repaintAll(self):
        repainAllParameters = self.getRepaintAllParameters()
        self.makeUidlRequest('', repainAllParameters, False)

    def analyzeLayouts(self):
        """Requests an analyze of layouts, to find inconsistencies. Exclusively used
        for debugging during development.
        """
        params = self.getRepaintAllParameters() + '&analyzeLayouts=1'
        self.makeUidlRequest('', params, False)

    def makeUidlRequest(self, *args):
        """Makes an UIDL request to the server.

        @param requestData
                   Data that is passed to the server.
        @param extraParams
                   Parameters that are added as GET parameters to the url.
                   Contains key=value pairs joined by & characters or is empty if
                   no parameters should be added. Should not start with any
                   special character.
        @param forceSync
                   true if the request should be synchronous, false otherwise
        """
        _0 = args
        _1 = len(args)
        if _1 == 1:
            string, = _0
            self.makeUidlRequest(string, '', False)
        elif _1 == 3:
            requestData, extraParams, forceSync = _0
            self.startRequest()
            # Security: double cookie submission pattern
            payload = self._uidlSecurityKey + self.VAR_BURST_SEPARATOR + requestData
            VConsole.log('Making UIDL Request with params: ' + payload)
            if self._configuration.usePortletURLs():
                uri = self._configuration.getPortletUidlURLBase()
            else:
                uri = self.getAppUri() + 'UIDL'
            if extraParams is not None and len(extraParams) > 0:
                uri = self.addGetParameters(uri, extraParams)
            if self._windowName is not None and len(self._windowName) > 0:
                uri = self.addGetParameters(uri, 'windowName=' + self._windowName)
            self.doUidlRequest(uri, payload, forceSync)
        else:
            raise ARGERROR(1, 3)

    def doUidlRequest(self, uri, payload, synchronous):
        """Sends an asynchronous or synchronous UIDL request to the server using the
        given URI.

        @param uri
                   The URI to use for the request. May includes GET parameters
        @param payload
                   The contents of the request to send
        @param synchronous
                   true if the request should be synchronous, false otherwise
        """
        if not synchronous:

            class requestCallback(RequestCallback):

                def onError(self, request, exception):
                    self.showCommunicationError(exception.getMessage())
                    self.endRequest()
                    if not self.applicationRunning:
                        # start failed, let's try to start the next app
                        ApplicationConfiguration.startNextApplication()

                def onResponseReceived(self, request, response):
                    VConsole.log('Server visit took ' + String.valueOf.valueOf(Date().getTime() - self.requestStartTime.getTime()) + 'ms')
                    statusCode = response.getStatusCode()
                    _0 = statusCode
                    _1 = False
                    while True:
                        if _0 == 0:
                            _1 = True
                            self.showCommunicationError('Invalid status code 0 (server down?)')
                            self.endRequest()
                            return
                        if (_1 is True) or (_0 == 401):
                            _1 = True
                            self.showAuthenticationError('')
                            self.endRequest()
                            return
                        if (_1 is True) or (_0 == 503):
                            _1 = True
                            delay = int(response.getHeader('Retry-After'))
                            VConsole.log('503, retrying in ' + delay + 'msec')


                            class _2_(Timer):

                                def run(self):
                                    self.activeRequests -= 1
                                    self.doUidlRequest(self.uri, self.payload, self.synchronous)


                            _2_ = self._2_()
                            _2_.schedule(delay)
                            return
                        break
                    if statusCode / 100 == 4:
                        # Handle all 4xx errors the same way as (they are
                        # all permanent errors)
                        self.showCommunicationError('UIDL could not be read from server. Check servlets mappings. Error code: ' + statusCode)
                        self.endRequest()
                        return
                    start = Date()
                    # for(;;);[realjson]
                    jsonText = response.getText()[9:len(response.getText()) - 1]
                    try:
                        json = self.parseJSONResponse(jsonText)
                    except Exception, e:
                        self.endRequest()
                        self.showCommunicationError(e.getMessage() + ' - Original JSON-text:' + jsonText)
                        return
                    VConsole.log('JSON parsing took ' + (Date().getTime() - start.getTime()) + 'ms')
                    if self.applicationRunning:
                        self.handleReceivedJSONMessage(start, jsonText, json)
                    else:
                        self.applicationRunning = True
                        self.handleWhenCSSLoaded(jsonText, json)
                        ApplicationConfiguration.startNextApplication()

            try:
                self.doAsyncUIDLRequest(uri, payload, self.requestCallback)
            except RequestException, e:
                VConsole.error(e)
                self.endRequest()
        else:
            # Synchronized call, discarded response (leaving the page)
            syncXHR = SynchronousXHR.create()
            syncXHR.synchronousPost(uri + '&' + self.PARAM_UNLOADBURST + '=1', payload)
            # Although we are in theory leaving the page, the page may still
            # stay open. End request properly here too. See #3289

            self.endRequest()

    def doAsyncUIDLRequest(self, uri, payload, requestCallback):
        """Sends an asynchronous UIDL request to the server using the given URI.

        @param uri
                   The URI to use for the request. May includes GET parameters
        @param payload
                   The contents of the request to send
        @param requestCallback
                   The handler for the response
        @throws RequestException
                    if the request could not be sent
        """
        rb = RequestBuilder(RequestBuilder.POST, uri)
        # TODO enable timeout
        # rb.setTimeoutMillis(timeoutMillis);
        rb.setHeader('Content-Type', 'text/plain;charset=utf-8')
        rb.setRequestData(payload)
        rb.setCallback(requestCallback)
        rb.send()

    _cssWaits = 0
    MAX_CSS_WAITS = 100

    def handleWhenCSSLoaded(self, jsonText, json):
        heightOfLoadElement = DOM.getElementPropertyInt(self._loadElement, 'offsetHeight')
        if heightOfLoadElement == 0 and self._cssWaits < self.MAX_CSS_WAITS:


            class _4_(Timer):

                def run(self):
                    self.handleWhenCSSLoaded(self.jsonText, self.json)


            _4_ = self._4_()
            _4_.schedule(50)
            VConsole.log('Assuming CSS loading is not complete, ' + 'postponing render phase. ' + '(.v-loading-indicator height == 0)')
            self._cssWaits += 1
        else:
            self.handleReceivedJSONMessage(Date(), jsonText, json)
            if self._cssWaits >= self.MAX_CSS_WAITS:
                VConsole.error('CSS files may have not loaded properly.')

    def showCommunicationError(self, details):
        """Shows the communication error notification.

        @param details
                   Optional details for debugging.
        """
        VConsole.error('Communication error: ' + details)
        self.showError(details, self._configuration.getCommunicationErrorCaption(), self._configuration.getCommunicationErrorMessage(), self._configuration.getCommunicationErrorUrl())

    def showAuthenticationError(self, details):
        """Shows the authentication error notification.

        @param details
                   Optional details for debugging.
        """
        VConsole.error('Authentication error: ' + details)
        self.showError(details, self._configuration.getAuthorizationErrorCaption(), self._configuration.getAuthorizationErrorMessage(), self._configuration.getAuthorizationErrorUrl())

    def showError(self, details, caption, message, url):
        """Shows the error notification.

        @param details
                   Optional details for debugging.
        """
        html = self.StringBuilder()
        if caption is not None:
            html.append('<h1>')
            html.append(caption)
            html.append('</h1>')
        if message is not None:
            html.append('<p>')
            html.append(message)
            html.append('</p>')
        if len(html) > 0:
            # Add error description
            html.append('<br/><p><I style=\"font-size:0.7em\">')
            html.append(details)
            html.append('</I></p>')
            n = VNotification(1000 * 60 * 45)
            n.addEventListener(self.NotificationRedirect(url))
            n.show(str(html), VNotification.CENTERED_TOP, VNotification.STYLE_SYSTEM)
        else:
            self.redirect(url)

    def startRequest(self):
        self._activeRequests += 1
        self._requestStartTime = Date()
        # show initial throbber
        if self._loadTimer is None:

            class _5_(Timer):

                def run(self):
                    # IE7 does not properly cancel the event with
                    # loadTimer.cancel() so we have to check that we really
                    # should make it visible

                    if self.loadTimer is not None:
                        self.showLoadingIndicator()

            _5_ = self._5_()
            self._loadTimer = _5_
            # First one kicks in at 300ms
        self._loadTimer.schedule(300)

    def endRequest(self):
        if self.applicationRunning:
            self.checkForPendingVariableBursts()
            self.runPostRequestHooks(self._configuration.getRootPanelId())
        self._activeRequests -= 1

        class _6_(Command):

            def execute(self):
                if self.activeRequests == 0:
                    self.hideLoadingIndicator()

        _6_ = self._6_()
        Scheduler.get().scheduleDeferred(_6_)

    def checkForPendingVariableBursts(self):
        """This method is called after applying uidl change set to application.

        It will clean current and queued variable change sets. And send next
        change set if it exists.
        """
        self.cleanVariableBurst(self._pendingVariables)
        if len(self._pendingVariableBursts) > 0:
            _0 = True
            iterator = self._pendingVariableBursts
            while True:
                if _0 is True:
                    _0 = False
                if not iterator.hasNext():
                    break
                self.cleanVariableBurst(iterator.next())
            nextBurst = self._pendingVariableBursts[0]
            self._pendingVariableBursts.remove(0)
            self.buildAndSendVariableBurst(nextBurst, False)

    def cleanVariableBurst(self, variableBurst):
        """Cleans given queue of variable changes of such changes that came from
        components that do not exist anymore.

        @param variableBurst
        """
        _0 = True
        i = 1
        while True:
            if _0 is True:
                _0 = False
            else:
                i += 2
            if not (i < len(variableBurst)):
                break
            id = variableBurst[i]
            id = id[:id.find(self.VAR_FIELD_SEPARATOR)]
            if not (id in self._idToPaintableDetail) and not id.startswith('DD'):
                # variable owner does not exist anymore
                variableBurst.remove(i - 1)
                variableBurst.remove(i - 1)
                i -= 2
                VConsole.log('Removed variable from removed component: ' + id)

    def showLoadingIndicator(self):
        # show initial throbber
        if self._loadElement is None:
            self._loadElement = DOM.createDiv()
            DOM.setStyleAttribute(self._loadElement, 'position', 'absolute')
            DOM.appendChild(self._view.getElement(), self._loadElement)
            VConsole.log('inserting load indicator')
        DOM.setElementProperty(self._loadElement, 'className', 'v-loading-indicator')
        DOM.setStyleAttribute(self._loadElement, 'display', 'block')
        # Initialize other timers

        class _7_(Timer):

            def run(self):
                DOM.setElementProperty(self.loadElement, 'className', 'v-loading-indicator-delay')

        _7_ = self._7_()
        self._loadTimer2 = _7_
        # Second one kicks in at 1500ms from request start
        self._loadTimer2.schedule(1200)

        class _8_(Timer):

            def run(self):
                DOM.setElementProperty(self.loadElement, 'className', 'v-loading-indicator-wait')

        _8_ = self._8_()
        self._loadTimer3 = _8_
        # Third one kicks in at 5000ms from request start
        self._loadTimer3.schedule(4700)

    def hideLoadingIndicator(self):
        if self._loadTimer is not None:
            self._loadTimer.cancel()
            if self._loadTimer2 is not None:
                self._loadTimer2.cancel()
                self._loadTimer3.cancel()
            self._loadTimer = None
        if self._loadElement is not None:
            DOM.setStyleAttribute(self._loadElement, 'display', 'none')

    def isExecutingDeferredCommands(self):
        """Checks if deferred commands are (potentially) still being executed as a
        result of an update from the server. Returns true if a deferred command
        might still be executing, false otherwise. This will not work correctly
        if a deferred command is added in another deferred command.
        <p>
        Used by the native "client.isActive" function.
        </p>

        @return true if deferred commands are (potentially) being executed, false
                otherwise
        """
        s = Scheduler.get()
        if isinstance(s, VSchedulerImpl):
            return s.hasWorkQueued()
        else:
            return False

    def isLoadingIndicatorVisible(self):
        """Determines whether or not the loading indicator is showing.

        @return true if the loading indicator is visible
        """
        if self._loadElement is None:
            return False
        if self._loadElement.getStyle().getProperty('display') == 'none':
            return False
        return True

    @classmethod
    def parseJSONResponse(cls, jsonText):
        # -{
        #     	try {
        #     		return JSON.parse(jsonText);
        #     	} catch (ignored) {
        #     		return eval('(' + jsonText + ')');
        #     	}
        #     }-

        pass

    def handleReceivedJSONMessage(self, start, jsonText, json):
        self.handleUIDLMessage(start, jsonText, json)

    def handleUIDLMessage(self, start, jsonText, json):
        # Handle redirect
        if 'redirect' in json:
            url = json.getValueMap('redirect').getString('url')
            VConsole.log('redirecting to ' + url)
            self.redirect(url)
            return
        # Get security key
        if self.UIDL_SECURITY_TOKEN_ID in json:
            self._uidlSecurityKey = json.getString(self.UIDL_SECURITY_TOKEN_ID)
        if 'resources' in json:
            resources = json.getValueMap('resources')
            keyArray = resources.getKeyArray()
            l = len(keyArray)
            _0 = True
            i = 0
            while True:
                if _0 is True:
                    _0 = False
                else:
                    i += 1
                if not (i < l):
                    break
                key = keyArray.get(i)
                self._resourcesMap.put(key, resources.getAsString(key))
        if 'typeMappings' in json:
            self._configuration.addComponentMappings(json.getValueMap('typeMappings'), self._widgetSet)

        class c(Command):

            def execute(self):
                if 'locales' in self.json:
                    # Store locale data
                    valueMapArray = self.json.getJSValueMapArray('locales')
                    LocaleService.addLocales(valueMapArray)
                repaintAll = False
                meta = None
                if 'meta' in self.json:
                    meta = self.json.getValueMap('meta')
                    if 'repaintAll' in meta:
                        repaintAll = True
                        self.view.clear()
                        self.idToPaintableDetail.clear()
                        if 'invalidLayouts' in meta:
                            self.validatingLayouts = True
                            self.zeroWidthComponents = set()
                            self.zeroHeightComponents = set()
                    if 'timedRedirect' in meta:
                        timedRedirect = meta.getValueMap('timedRedirect')

                        class _9_(Timer):

                            def run(self):
                                self.redirect(self.timedRedirect.getString('url'))

                        _9_ = self._9_()
                        self.redirectTimer = _9_
                        self.sessionExpirationInterval = timedRedirect.getInt('interval')
                if self.redirectTimer is not None:
                    self.redirectTimer.schedule(1000 * self.sessionExpirationInterval)
                # Process changes
                changes = self.json.getJSValueMapArray('changes')
                updatedWidgets = list()
                self.relativeSizeChanges.clear()
                self.componentCaptionSizeChanges.clear()
                length = len(changes)
                _0 = True
                i = 0
                while True:
                    if _0 is True:
                        _0 = False
                    else:
                        i += 1
                    if not (i < length):
                        break
                    try:
                        change = changes.get(i)
                        VConsole.dirUIDL(change, self.configuration)
                        uidl = change.getChildUIDL(0)
                        # TODO optimize
                        paintable = self.getPaintable(uidl.getId())
                        if paintable is not None:
                            paintable.updateFromUIDL(uidl, _ApplicationConnection_this)
                            # paintable may have changed during render to
                            # another
                            # implementation, use the new one for updated
                            # widgets map
                            updatedWidgets.add(self.idToPaintableDetail.get(uidl.getId()).getComponent())
                        elif not (uidl.getTag() == self.configuration.getEncodedWindowTag()):
                            VConsole.error('Received update for ' + uidl.getTag() + ', but there is no such paintable (' + uidl.getId() + ') rendered.')
                        else:
                            pid = uidl.getId()
                            if not (pid in self.idToPaintableDetail):
                                self.registerPaintable(pid, self.view)
                            # VView does not call updateComponent so we
                            # register any event listeners here
                            cd = self.idToPaintableDetail.get(pid)
                            cd.registerEventListenersFromUIDL(uidl)
                            # Finally allow VView to update itself
                            self.view.updateFromUIDL(uidl, _ApplicationConnection_this)
                    except Throwable, e:
                        VConsole.error(e)
                if 'dd' in self.json:
                    # response contains data for drag and drop service
                    VDragAndDropManager.get().handleServerResponse(self.json.getValueMap('dd'))
                # Check which widgets' size has been updated
                sizeUpdatedWidgets = set()
                updatedWidgets.addAll(self.relativeSizeChanges)
                sizeUpdatedWidgets.addAll(self.componentCaptionSizeChanges)
                for paintable in updatedWidgets:
                    detail = self.idToPaintableDetail.get(self.getPid(paintable))
                    widget = paintable
                    oldSize = detail.getOffsetSize()
                    newSize = Size(widget.getOffsetWidth(), widget.getOffsetHeight())
                    if (oldSize is None) or (not (oldSize == newSize)):
                        sizeUpdatedWidgets.add(paintable)
                        detail.setOffsetSize(newSize)
                Util.componentSizeUpdated(sizeUpdatedWidgets)
                if meta is not None:
                    if 'appError' in meta:
                        error = meta.getValueMap('appError')
                        html = ''
                        if 'caption' in error and error.getString('caption') is not None:
                            html += '<h1>' + error.getAsString('caption') + '</h1>'
                        if 'message' in error and error.getString('message') is not None:
                            html += '<p>' + error.getAsString('message') + '</p>'
                        url = None
                        if 'url' in error:
                            url = error.getString('url')
                        if len(html) != 0:
                            # 45 min
                            n = VNotification(1000 * 60 * 45)
                            n.addEventListener(self.NotificationRedirect(url))
                            n.show(html, VNotification.CENTERED_TOP, VNotification.STYLE_SYSTEM)
                        else:
                            self.redirect(url)
                        self.applicationRunning = False
                    if self.validatingLayouts:
                        VConsole.printLayoutProblems(meta, _ApplicationConnection_this, self.zeroHeightComponents, self.zeroWidthComponents)
                        self.zeroHeightComponents = None
                        self.zeroWidthComponents = None
                        self.validatingLayouts = False
                if repaintAll:
                    # idToPaintableDetail is already cleanded at the start of
                    # the changeset handling, bypass cleanup.

                    self.unregistryBag.clear()
                else:
                    self.purgeUnregistryBag()
                # TODO build profiling for widget impl loading time
                prosessingTime = Date().getTime() - self.start.getTime()
                VConsole.log(' Processing time was ' + String.valueOf.valueOf(prosessingTime) + 'ms for ' + len(self.jsonText) + ' characters of JSON')
                VConsole.log('Referenced paintables: ' + len(self.idToPaintableDetail))
                self.endRequest()

        ApplicationConfiguration.runWhenWidgetsLoaded(self.c)

    def sendPendingVariableChangesSync(self):
        """This method assures that all pending variable changes are sent to server.
        Method uses synchronized xmlhttprequest and does not return before the
        changes are sent. No UIDL updates are processed and thus UI is left in
        inconsistent state. This method should be called only when closing
        windows - normally sendPendingVariableChanges() should be used.
        """
        # Redirect browser, null reloads current page
        if self.applicationRunning:
            self._pendingVariableBursts.add(self._pendingVariables)
            nextBurst = self._pendingVariableBursts[0]
            self._pendingVariableBursts.remove(0)
            self.buildAndSendVariableBurst(nextBurst, True)

    @classmethod
    def redirect(cls, url):
        # -{
        #     	if (url) {
        #     		$wnd.location = url;
        #     	} else {
        #     		$wnd.location.reload(false);
        #     	}
        #     }-

        pass

    def registerPaintable(self, pid, paintable):
        componentDetail = self.ComponentDetail(self, pid, paintable)
        self._idToPaintableDetail.put(pid, componentDetail)
        self.setPid(paintable.getElement(), pid)

    def setPid(self, el, pid):
        # -{
        #     	el.tkPid = pid;
        #     }-

        pass

    def getPid(self, *args):
        """Gets the paintableId for a specific paintable (a.k.a Vaadin Widget).
        <p>
        The paintableId is used in the UIDL to identify a specific widget
        instance, effectively linking the widget with it's server side Component.
        </p>

        @param paintable
                   the paintable who's id is needed
        @return the id for the given paintable
        ---
        Gets the paintableId using a DOM element - the element should be the main
        element for a paintable otherwise no id will be found. Use
        {@link #getPid(Paintable)} instead whenever possible.

        @see #getPid(Paintable)
        @param el
                   element of the paintable whose pid is desired
        @return the pid of the element's paintable, if it's a paintable
        """
        _0 = args
        _1 = len(args)
        if _1 == 1:
            if isinstance(_0[0], Element):
                el, = _0
            else:
                paintable, = _0
                return self.getPid(paintable.getElement())
        else:
            raise ARGERROR(1, 1)

    # -{
    #     	return el.tkPid;
    #     }-

    def getElementByPid(self, pid):
        """Gets the main element for the paintable with the given id. The revers of
        {@link #getPid(Element)}.

        @param pid
                   the pid of the widget whose element is desired
        @return the element for the paintable corresponding to the pid
        """
        return self.getPaintable(pid).getElement()

    def unregisterPaintable(self, p):
        """Unregisters the given paintable; always use after removing a paintable.
        This method does not remove the paintable from the DOM, but marks the
        paintable so that ApplicationConnection may clean up its references to
        it. Removing the widget from DOM is component containers responsibility.

        @param p
                   the paintable to remove
        """
        # add to unregistry que
        if p is None:
            VConsole.error('WARN: Trying to unregister null paintable')
            return
        id = self.getPid(p)
        if id is None:
            # Uncomment the following to debug unregistring components. No
            # paintables with null id should end here. At least one exception
            # is our VScrollTableRow, that is hacked to fake it self as a
            # Paintable to build support for sizing easier.

            # if (!(p instanceof VScrollTableRow)) {
            # VConsole.log("Trying to unregister Paintable not created by Application Connection.");
            # }
            if isinstance(p, HasWidgets):
                self.unregisterChildPaintables(p)
        else:
            self._unregistryBag.add(id)
            if isinstance(p, HasWidgets):
                self.unregisterChildPaintables(p)

    def purgeUnregistryBag(self):
        for id in self._unregistryBag:
            componentDetail = self._idToPaintableDetail.get(id)
            if componentDetail is None:
                # this should never happen, but it does :-( See e.g.
                # com.vaadin.tests.components.accordion.RemoveTabs (with test
                # script)

                VConsole.error('ApplicationConnetion tried to unregister component (id=' + id + ') that is never registered (or already unregistered)')
                continue
            # check if can be cleaned
            component = componentDetail.getComponent()
            if not component.isAttached():
                # clean reference from ac to paintable
                self._idToPaintableDetail.remove(id)
            # else NOP : same component has been reattached to another parent
            # or replaced by another component implementation.

        self._unregistryBag.clear()

    def unregisterChildPaintables(self, container):
        """Unregisters a paintable and all it's child paintables recursively. Use
        when after removing a paintable that contains other paintables. Does not
        unregister the given container itself. Does not actually remove the
        paintable from the DOM.

        @see #unregisterPaintable(Paintable)
        @param container
        """
        it = container
        while it.hasNext():
            w = it.next()
            if isinstance(w, Paintable):
                self.unregisterPaintable(w)
            elif isinstance(w, HasWidgets):
                self.unregisterChildPaintables(w)

    def getPaintable(self, *args):
        """Returns Paintable element by its id

        @param id
                   Paintable ID
        ---
        Get either existing or new Paintable for given UIDL.

        If corresponding Paintable has been previously painted, return it.
        Otherwise create and register a new Paintable from UIDL. Caller must
        update the returned Paintable from UIDL after it has been connected to
        parent.

        @param uidl
                   UIDL to create Paintable from.
        @return Either existing or new Paintable corresponding to UIDL.
        ---
        Returns a Paintable element by its root element

        @param element
                   Root element of the paintable
        """
        _0 = args
        _1 = len(args)
        if _1 == 1:
            if isinstance(_0[0], Element):
                element, = _0
                return self.getPaintable(self.getPid(element))
            elif isinstance(_0[0], UIDL):
                uidl, = _0
                id = uidl.getId()
                w = self.getPaintable(id)
                if w is not None:
                    return w
                else:
                    w = self._widgetSet.createWidget(uidl, self._configuration)
                    self.registerPaintable(id, w)
                    return w
            else:
                id, = _0
                componentDetail = self._idToPaintableDetail.get(id)
                if componentDetail is None:
                    return None
                else:
                    return componentDetail.getComponent()
        else:
            raise ARGERROR(1, 1)

    def addVariableToQueue(self, paintableId, variableName, encodedValue, immediate, type):
        id = paintableId + self.VAR_FIELD_SEPARATOR + variableName + self.VAR_FIELD_SEPARATOR + type
        _0 = True
        i = 1
        while True:
            if _0 is True:
                _0 = False
            else:
                i += 2
            if not (i < len(self._pendingVariables)):
                break
            if self._pendingVariables[i] == id:
                self._pendingVariables.remove(i - 1)
                self._pendingVariables.remove(i - 1)
                break
        self._pendingVariables.add(encodedValue)
        self._pendingVariables.add(id)
        if immediate:
            self.sendPendingVariableChanges()

    def sendPendingVariableChanges(self):
        """This method sends currently queued variable changes to server. It is
        called when immediate variable update must happen.

        To ensure correct order for variable changes (due servers multithreading
        or network), we always wait for active request to be handler before
        sending a new one. If there is an active request, we will put varible
        "burst" to queue that will be purged after current request is handled.
        """
        if self.applicationRunning:
            if self.hasActiveRequest():
                # skip empty queues if there are pending bursts to be sent
                if (
                    (len(self._pendingVariables) > 0) or (len(self._pendingVariableBursts) == 0)
                ):
                    burst = self._pendingVariables.clone()
                    self._pendingVariableBursts.add(burst)
                    self._pendingVariables.clear()
            else:
                self.buildAndSendVariableBurst(self._pendingVariables, False)

    def buildAndSendVariableBurst(self, pendingVariables, forceSync):
        """Build the variable burst and send it to server.

        When sync is forced, we also force sending of all pending variable-bursts
        at the same time. This is ok as we can assume that DOM will never be
        updated after this.

        @param pendingVariables
                   Vector of variable changes to send
        @param forceSync
                   Should we use synchronous request?
        """
        req = str()
        while not pendingVariables.isEmpty():
            if ApplicationConfiguration.isDebugMode():
                Util.logVariableBurst(self, pendingVariables)
            _0 = True
            i = 0
            while True:
                if _0 is True:
                    _0 = False
                else:
                    i += 1
                if not (i < len(pendingVariables)):
                    break
                if i > 0:
                    if i % 2 == 0:
                        req.__add__(self.VAR_RECORD_SEPARATOR)
                    else:
                        req.__add__(self.VAR_FIELD_SEPARATOR)
                req.__add__(pendingVariables[i])
            pendingVariables.clear()
            # Append all the busts to this synchronous request
            if forceSync and not self._pendingVariableBursts.isEmpty():
                pendingVariables = self._pendingVariableBursts[0]
                self._pendingVariableBursts.remove(0)
                req.__add__(self.VAR_BURST_SEPARATOR)
        self.makeUidlRequest(str(req), '', forceSync)

    def updateVariable(self, *args):
        """Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.
        <p>
        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.
        </p>

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.

        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update.

        A null array is sent as an empty array.

        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        ---
        Sends a new value for the given paintables given variable to the server.

        The update is actually queued to be sent at a suitable time. If immediate
        is true, the update is sent as soon as possible. If immediate is false,
        the update will be sent along with the next immediate update. </p>

        A null array is sent as an empty array.


        @param paintableId
                   the id of the paintable that owns the variable
        @param variableName
                   the name of the variable
        @param newValue
                   the new value to be sent
        @param immediate
                   true if the update is to be sent as soon as possible
        """
        _0 = args
        _1 = len(args)
        if _1 == 4:
            if isinstance(_0[2], Object):
                paintableId, variableName, values, immediate = _0
                buf = str()
                if values is not None:
                    _0 = True
                    i = 0
                    while True:
                        if _0 is True:
                            _0 = False
                        else:
                            i += 1
                        if not (i < values.length):
                            break
                        if i > 0:
                            buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                        value = values[i]
                        transportType = self.getTransportType(value)
                        # first char tells the type in array
                        buf.__add__(transportType)
                        if transportType == 'p':
                            buf.__add__(self.getPid(value))
                        else:
                            buf.__add__(value)
                self.addVariableToQueue(paintableId, variableName, str(buf), immediate, 'a')
            elif isinstance(_0[2], Paintable):
                paintableId, variableName, newValue, immediate = _0
                pid = self.getPid(newValue) if newValue is not None else None
                self.addVariableToQueue(paintableId, variableName, pid, immediate, 'p')
            elif isinstance(_0[2], boolean):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, 'true' if newValue else 'false', immediate, 'b')
            elif isinstance(_0[2], dict):
                paintableId, variableName, map, immediate = _0
                buf = str()
                iterator = map.keys()
                while iterator.hasNext():
                    key = iterator.next()
                    value = map.get(key)
                    transportType = self.getTransportType(value)
                    buf.__add__(transportType)
                    buf.__add__(key)
                    buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                    if transportType == 'p':
                        buf.__add__(self.getPid(value))
                    else:
                        buf.__add__(value)
                    if iterator.hasNext():
                        buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                self.addVariableToQueue(paintableId, variableName, str(buf), immediate, 'm')
            elif isinstance(_0[2], double):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'd')
            elif isinstance(_0[2], float):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'f')
            elif isinstance(_0[2], int):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'i')
            elif isinstance(_0[2], long):
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, '' + newValue, immediate, 'l')
            else:
                paintableId, variableName, values, immediate = _0
                buf = str()
                if values is not None:
                    _0 = True
                    i = 0
                    while True:
                        if _0 is True:
                            _0 = False
                        else:
                            i += 1
                        if not (i < values.length):
                            break
                        buf.__add__(values[i])
                        # there will be an extra separator at the end to differentiate
                        # between an empty array and one containing an empty string
                        # only
                        buf.__add__(self.VAR_ARRAYITEM_SEPARATOR)
                self.addVariableToQueue(paintableId, variableName, str(buf), immediate, 'c')
                paintableId, variableName, newValue, immediate = _0
                self.addVariableToQueue(paintableId, variableName, newValue, immediate, 's')
        else:
            raise ARGERROR(4, 4)

    def getTransportType(self, value):
        if isinstance(value, str):
            return 's'
        elif isinstance(value, Paintable):
            return 'p'
        elif isinstance(value, bool):
            return 'b'
        elif isinstance(value, int):
            return 'i'
        elif isinstance(value, float):
            return 'f'
        elif isinstance(value, float):
            return 'd'
        elif isinstance(value, long):
            return 'l'
        elif isinstance(value, Enum):
            return 's'
            # transported as string representation
        return 'u'

    def updateComponent(self, component, uidl, manageCaption):
        """Update generic component features.

        <h2>Selecting correct implementation</h2>

        <p>
        The implementation of a component depends on many properties, including
        styles, component features, etc. Sometimes the user changes those
        properties after the component has been created. Calling this method in
        the beginning of your updateFromUIDL -method automatically replaces your
        component with more appropriate if the requested implementation changes.
        </p>

        <h2>Caption, icon, error messages and description</h2>

        <p>
        Component can delegate management of caption, icon, error messages and
        description to parent layout. This is optional an should be decided by
        component author
        </p>

        <h2>Component visibility and disabling</h2>

        This method will manage component visibility automatically and if
        component is an instanceof FocusWidget, also handle component disabling
        when needed.

        @param component
                   Widget to be updated, expected to implement an instance of
                   Paintable
        @param uidl
                   UIDL to be painted
        @param manageCaption
                   True if you want to delegate caption, icon, description and
                   error message management to parent.

        @return Returns true iff no further painting is needed by caller
        """
        pid = self.getPid(component.getElement())
        if pid is None:
            VConsole.error('Trying to update an unregistered component: ' + Util.getSimpleName(component))
            return True
        componentDetail = self._idToPaintableDetail.get(pid)
        if componentDetail is None:
            VConsole.error('ComponentDetail not found for ' + Util.getSimpleName(component) + ' with PID ' + pid + '. This should not happen.')
            return True
        # If the server request that a cached instance should be used, do
        # nothing
        if uidl.getBooleanAttribute('cached'):
            return True
        # register the listened events by the server-side to the event-handler
        # of the component
        componentDetail.registerEventListenersFromUIDL(uidl)
        # Visibility
        visible = not uidl.getBooleanAttribute('invisible')
        wasVisible = component.isVisible()
        component.setVisible(visible)
        if wasVisible != visible:
            # Changed invisibile <-> visible
            if wasVisible and manageCaption:
                # Must hide caption when component is hidden
                parent = Util.getLayout(component)
                if parent is not None:
                    parent.updateCaption(component, uidl)
        if self._configuration.useDebugIdInDOM() and uidl.getId().startswith('PID_S'):
            DOM.setElementProperty(component.getElement(), 'id', uidl.getId()[5:])
        if not visible:
            # component is invisible, delete old size to notify parent, if
            # later make visible
            componentDetail.setOffsetSize(None)
            return True
        # Switch to correct implementation if needed
        if (
            not self._widgetSet.isCorrectImplementation(component, uidl, self._configuration)
        ):
            w = self._widgetSet.createWidget(uidl, self._configuration)
            # deferred binding check TODO change isCorrectImplementation to use
            # stored detected class, making this innecessary
            if w.getClass() != component.getClass():
                parent = Util.getLayout(component)
                if parent is not None:
                    parent.replaceChildComponent(component, w)
                    self.unregisterPaintable(component)
                    self.registerPaintable(uidl.getId(), w)
                    w.updateFromUIDL(uidl, self)
                    return True
        enabled = not uidl.getBooleanAttribute('disabled')
        if uidl.hasAttribute('tabindex') and isinstance(component, Focusable):
            component.setTabIndex(uidl.getIntAttribute('tabindex'))
        # Disabled state may affect (override) tabindex so the order must be
        # first setting tabindex, then enabled state.

        if isinstance(component, FocusWidget):
            fw = component
            fw.setEnabled(enabled)
        styleBuf = str()
        primaryName = component.getStylePrimaryName()
        styleBuf.__add__(primaryName)
        # first disabling and read-only status
        if not enabled:
            styleBuf.__add__(' ')
            styleBuf.__add__('v-disabled')
        if uidl.getBooleanAttribute('readonly'):
            styleBuf.__add__(' ')
            styleBuf.__add__('v-readonly')
        # add additional styles as css classes, prefixed with component default
        # stylename
        if uidl.hasAttribute('style'):
            styles = uidl.getStringAttribute('style').split(' ')
            _0 = True
            i = 0
            while True:
                if _0 is True:
                    _0 = False
                else:
                    i += 1
                if not (i < len(styles)):
                    break
                styleBuf.__add__(' ')
                styleBuf.__add__(primaryName)
                styleBuf.__add__('-')
                styleBuf.__add__(styles[i])
                styleBuf.__add__(' ')
                styleBuf.__add__(styles[i])
        # add modified classname to Fields
        if uidl.hasAttribute('modified') and isinstance(component, Field):
            styleBuf.__add__(' ')
            styleBuf.__add__(self._MODIFIED_CLASSNAME)
        tooltipInfo = componentDetail.getTooltipInfo(None)
        # Update tooltip
        if uidl.hasAttribute(self.ATTRIBUTE_DESCRIPTION):
            tooltipInfo.setTitle(uidl.getStringAttribute(self.ATTRIBUTE_DESCRIPTION))
        else:
            tooltipInfo.setTitle(None)
        # add error classname to components w/ error
        if uidl.hasAttribute(self.ATTRIBUTE_ERROR):
            tooltipInfo.setErrorUidl(uidl.getErrors())
            styleBuf.__add__(' ')
            styleBuf.__add__(primaryName)
            styleBuf.__add__(self._ERROR_CLASSNAME_EXT)
        else:
            tooltipInfo.setErrorUidl(None)
        # add required style to required components
        if uidl.hasAttribute('required'):
            styleBuf.__add__(' ')
            styleBuf.__add__(primaryName)
            styleBuf.__add__(self._REQUIRED_CLASSNAME_EXT)
        # Styles + disabled & readonly
        component.setStyleName(str(styleBuf))
        # Set captions
        if manageCaption:
            parent = Util.getLayout(component)
            if parent is not None:
                parent.updateCaption(component, uidl)
        # updateComponentSize need to be after caption update so caption can be
        # taken into account

        self.updateComponentSize(componentDetail, uidl)
        return False

    def updateComponentSize(self, cd, uidl):
        # Traverses recursively child widgets until ContainerResizedListener child
        # widget is found. They will delegate it further if needed.
        # 
        # @param container

        w = uidl.getStringAttribute('width') if uidl.hasAttribute('width') else ''
        h = uidl.getStringAttribute('height') if uidl.hasAttribute('height') else ''
        relativeWidth = Util.parseRelativeSize(w)
        relativeHeight = Util.parseRelativeSize(h)
        # First update maps so they are correct in the setHeight/setWidth calls
        if (relativeHeight >= 0.0) or (relativeWidth >= 0.0):
            # One or both is relative
            relativeSize = FloatSize(relativeWidth, relativeHeight)
            if cd.getRelativeSize() is None and cd.getOffsetSize() is not None:
                # The component has changed from absolute size to relative size
                self._relativeSizeChanges.add(cd.getComponent())
            cd.setRelativeSize(relativeSize)
        elif relativeHeight < 0.0 and relativeWidth < 0.0:
            if cd.getRelativeSize() is not None:
                # The component has changed from relative size to absolute size
                self._relativeSizeChanges.add(cd.getComponent())
            cd.setRelativeSize(None)
        component = cd.getComponent()
        # Set absolute sizes
        if relativeHeight < 0.0:
            component.setHeight(h)
        if relativeWidth < 0.0:
            component.setWidth(w)
        # Set relative sizes
        if (relativeHeight >= 0.0) or (relativeWidth >= 0.0):
            # One or both is relative
            self.handleComponentRelativeSize(cd)

    _runningLayout = False

    def runDescendentsLayout(self, container):
        """Causes a re-calculation/re-layout of all paintables in a container.

        @param container
        """
        if self._runningLayout:
            return
        self._runningLayout = True
        self.internalRunDescendentsLayout(container)
        self._runningLayout = False

    def forceLayout(self):
        """This will cause re-layouting of all components. Mainly used for
        development. Published to JavaScript.
        """
        set = set()
        for cd in self._idToPaintableDetail.values():
            set.add(cd.getComponent())
        Util.componentSizeUpdated(set)

    def internalRunDescendentsLayout(self, container):
        # getConsole().log(
        # "runDescendentsLayout(" + Util.getSimpleName(container) + ")");
        childWidgets = container
        while childWidgets.hasNext():
            child = childWidgets.next()
            if isinstance(child, Paintable):
                if self.handleComponentRelativeSize(child):
                    # Only need to propagate event if "child" has a relative
                    # size

                    if isinstance(child, ContainerResizedListener):
                        child.iLayout()
                    if isinstance(child, HasWidgets):
                        childContainer = child
                        self.internalRunDescendentsLayout(childContainer)
            elif isinstance(child, HasWidgets):
                # propagate over non Paintable HasWidgets
                self.internalRunDescendentsLayout(child)

    def handleComponentRelativeSize(self, *args):
        """Converts relative sizes into pixel sizes.

        @param child
        @return true if the child has a relative size
        ---
        Converts relative sizes into pixel sizes.

        @param child
        @return true if the child has a relative size
        """
        _0 = args
        _1 = len(args)
        if _1 == 1:
            if isinstance(_0[0], ComponentDetail):
                cd, = _0
                if cd is None:
                    return False
                debugSizes = False
                relativeSize = cd.getRelativeSize()
                if relativeSize is None:
                    return False
                widget = cd.getComponent()
                horizontalScrollBar = False
                verticalScrollBar = False
                parent = Util.getLayout(widget)
                # Parent-less components (like sub-windows) are relative to browser
                # window.
                if parent is None:
                    renderSpace = RenderSpace(Window.getClientWidth(), Window.getClientHeight())
                else:
                    renderSpace = parent.getAllocatedSpace(widget)
                if relativeSize.getHeight() >= 0:
                    if renderSpace is not None:
                        if renderSpace.getScrollbarSize() > 0:
                            if relativeSize.getWidth() > 100:
                                horizontalScrollBar = True
                            elif relativeSize.getWidth() < 0 and renderSpace.getWidth() > 0:
                                offsetWidth = widget.getOffsetWidth()
                                width = renderSpace.getWidth()
                                if offsetWidth > width:
                                    horizontalScrollBar = True
                        height = renderSpace.getHeight()
                        if horizontalScrollBar:
                            height -= renderSpace.getScrollbarSize()
                        if self._validatingLayouts and height <= 0:
                            self._zeroHeightComponents.add(cd.getComponent())
                        height = (height * relativeSize.getHeight()) / 100.0
                        if height < 0:
                            height = 0
                        if debugSizes:
                            VConsole.log('Widget ' + Util.getSimpleName(widget) + '/' + self.getPid(widget.getElement()) + ' relative height ' + relativeSize.getHeight() + '% of ' + renderSpace.getHeight() + 'px (reported by ' + Util.getSimpleName(parent) + '/' + ('?' if parent is None else parent.hashCode()) + ') : ' + height + 'px')
                        widget.setHeight(height + 'px')
                    else:
                        widget.setHeight(relativeSize.getHeight() + '%')
                        VConsole.error(Util.getLayout(widget).getClass().getName() + ' did not produce allocatedSpace for ' + widget.getClass().getName())
                if relativeSize.getWidth() >= 0:
                    if renderSpace is not None:
                        width = renderSpace.getWidth()
                        if renderSpace.getScrollbarSize() > 0:
                            if relativeSize.getHeight() > 100:
                                verticalScrollBar = True
                            elif (
                                relativeSize.getHeight() < 0 and renderSpace.getHeight() > 0 and widget.getOffsetHeight() > renderSpace.getHeight()
                            ):
                                verticalScrollBar = True
                        if verticalScrollBar:
                            width -= renderSpace.getScrollbarSize()
                        if self._validatingLayouts and width <= 0:
                            self._zeroWidthComponents.add(cd.getComponent())
                        width = (width * relativeSize.getWidth()) / 100.0
                        if width < 0:
                            width = 0
                        if debugSizes:
                            VConsole.log('Widget ' + Util.getSimpleName(widget) + '/' + self.getPid(widget.getElement()) + ' relative width ' + relativeSize.getWidth() + '% of ' + renderSpace.getWidth() + 'px (reported by ' + Util.getSimpleName(parent) + '/' + ('?' if parent is None else self.getPid(parent)) + ') : ' + width + 'px')
                        widget.setWidth(width + 'px')
                    else:
                        widget.setWidth(relativeSize.getWidth() + '%')
                        VConsole.error(Util.getLayout(widget).getClass().getName() + ' did not produce allocatedSpace for ' + widget.getClass().getName())
                return True
            else:
                child, = _0
                return self.handleComponentRelativeSize(self._idToPaintableDetail.get(self.getPid(child.getElement())))
        else:
            raise ARGERROR(1, 1)

    def getRelativeSize(self, widget):
        """Gets the specified Paintables relative size (percent).

        @param widget
                   the paintable whose size is needed
        @return the the size if the paintable is relatively sized, -1 otherwise
        """
        return self._idToPaintableDetail.get(self.getPid(widget.getElement())).getRelativeSize()

    def getResource(self, name):
        """Gets a recource that has been pre-loaded via UIDL, such as custom
        layouts.

        @param name
                   identifier of the resource to get
        @return the resource
        """
        return self._resourcesMap[name]

    def getContextMenu(self):
        """Singleton method to get instance of app's context menu.

        @return VContextMenu object
        """
        if self._contextMenu is None:
            self._contextMenu = VContextMenu()
            DOM.setElementProperty(self._contextMenu.getElement(), 'id', 'PID_VAADIN_CM')
        return self._contextMenu

    def translateVaadinUri(self, uidlUri):
        """Translates custom protocols in UIDL URI's to be recognizable by browser.
        All uri's from UIDL should be routed via this method before giving them
        to browser due URI's in UIDL may contain custom protocols like theme://.

        @param uidlUri
                   Vaadin URI from uidl
        @return translated URI ready for browser
        """
        if uidlUri is None:
            return None
        if uidlUri.startswith('theme://'):
            themeUri = self._configuration.getThemeUri()
            if themeUri is None:
                VConsole.error('Theme not set: ThemeResource will not be found. (' + uidlUri + ')')
            uidlUri = themeUri + (uidlUri[7:])
        if uidlUri.startswith('app://'):
            uidlUri = self.getAppUri() + (uidlUri[6:])
        return uidlUri

    def getThemeUri(self):
        """Gets the URI for the current theme. Can be used to reference theme
        resources.

        @return URI to the current theme
        """
        return self._configuration.getThemeUri()

    class NotificationRedirect(VNotification, EventListener):
        """Listens for Notification hide event, and redirects. Used for system
        messages, such as session expired.
        """
        # Extended title handling
        _url = None

        def __init__(self, url):
            self._url = url

        def notificationHidden(self, event):
            self.redirect(self._url)

    def getTooltipTitleInfo(self, titleOwner, key):
        """Data showed in tooltips are stored centrilized as it may be needed in
        varios place: caption, layouts, and in owner components themselves.

        Updating TooltipInfo is done in updateComponent method.
        """
        if None is titleOwner:
            return None
        cd = self._idToPaintableDetail.get(self.getPid(titleOwner))
        if None is not cd:
            return cd.getTooltipInfo(key)
        else:
            return None

    def handleTooltipEvent(self, *args):
        """Component may want to delegate Tooltip handling to client. Layouts add
        Tooltip (description, errors) to caption, but some components may want
        them to appear one other elements too.

        Events wanted by this handler are same as in Tooltip.TOOLTIP_EVENTS

        @param event
        @param owner
        ---
        Component may want to delegate Tooltip handling to client. Layouts add
        Tooltip (description, errors) to caption, but some components may want
        them to appear one other elements too.

        Events wanted by this handler are same as in Tooltip.TOOLTIP_EVENTS

        @param event
        @param owner
        @param key
                   the key for tooltip if this is "additional" tooltip, null for
                   components "main tooltip"
        """
        _0 = args
        _1 = len(args)
        if _1 == 2:
            event, owner = _0
            self._tooltip.handleTooltipEvent(event, owner, None)
        elif _1 == 3:
            event, owner, key = _0
            self._tooltip.handleTooltipEvent(event, owner, key)
        else:
            raise ARGERROR(2, 3)

    def addPngFix(self, el):
        """Adds PNG-fix conditionally (only for IE6) to the specified IMG -element.

        @param el
                   the IMG element to fix
        """
        # Helper to run layout functions triggered by child components with a
        # decent interval.

        b = BrowserInfo.get()
        if b.isIE6():
            Util.addPngFix(el)

    class layoutTimer(Timer):
        _isPending = False

        def schedule(self, delayMillis):
            if not self._isPending:
                super(_11_, self).schedule(delayMillis)
                self._isPending = True

        def run(self):
            VConsole.log('Running re-layout of ' + self.view.getClass().getName())
            self.runDescendentsLayout(self.view)
            self._isPending = False

    def requestLayoutPhase(self):
        """Components can call this function to run all layout functions. This is
        usually done, when component knows that its size has changed.
        """
        self.layoutTimer.schedule(500)

    _windowName = None

    def setWindowName(self, newName):
        """Reset the name of the current browser-window. This should reflect the
        window-name used in the server, but might be different from the
        window-object target-name on client.

        @param stringAttribute
                   New name for the window.
        """
        self._windowName = newName

    def getWindowName(self):
        return self._windowName

    def getUidlSecurityKey(self):
        return self._uidlSecurityKey

    def captionSizeUpdated(self, component):
        """Use to notify that the given component's caption has changed; layouts may
        have to be recalculated.

        @param component
                   the Paintable whose caption has changed
        """
        self._componentCaptionSizeChanges.add(component)

    def getView(self):
        """Gets the main view, a.k.a top-level window.

        @return the main view
        """
        return self._view

    def registerTooltip(self, paintable, key, tooltip):
        """If component has several tooltips in addition to the one provided by
        {@link com.vaadin.ui.AbstractComponent}, component can register them with
        this method.
        <p>
        Component must also pipe events to
        {@link #handleTooltipEvent(Event, Paintable, Object)} method.
        <p>
        This method can also be used to deregister tooltips by using null as
        tooltip

        @param paintable
                   Paintable "owning" this tooltip
        @param key
                   key assosiated with given tooltip. Can be any object. For
                   example a related dom element. Same key must be given for
                   {@link #handleTooltipEvent(Event, Paintable, Object)} method.

        @param tooltip
                   the TooltipInfo object containing details shown in tooltip,
                   null if deregistering tooltip
        """
        componentDetail = self._idToPaintableDetail.get(self.getPid(paintable))
        componentDetail.putAdditionalTooltip(key, tooltip)

    def getConfiguration(self):
        """Gets the {@link ApplicationConfiguration} for the current application.

        @see ApplicationConfiguration
        @return the configuration for this application
        """
        return self._configuration

    def hasEventListeners(self, paintable, eventIdentifier):
        """Checks if there is a registered server side listener for the event. The
        list of events which has server side listeners is updated automatically
        before the component is updated so the value is correct if called from
        updatedFromUIDL.

        @param eventIdentifier
                   The identifier for the event
        @return true if at least one listener has been registered on server side
                for the event identified by eventIdentifier.
        """
        return self._idToPaintableDetail.get(self.getPid(paintable)).hasEventListeners(eventIdentifier)

    @classmethod
    def addGetParameters(cls, uri, extraParams):
        """Adds the get parameters to the uri and returns the new uri that contains
        the parameters.

        @param uri
                   The uri to which the parameters should be added.
        @param extraParams
                   One or more parameters in the format "a=b" or "c=d&e=f". An
                   empty string is allowed but will not modify the url.
        @return The modified URI with the get parameters in extraParams added.
        """
        if (extraParams is None) or (len(extraParams) == 0):
            return uri
        # RFC 3986: The query component is indicated by the first question
        # mark ("?") character and terminated by a number sign ("#") character
        # or by the end of the URI.
        fragment = None
        hashPosition = uri.find('#')
        if hashPosition != -1:
            # Fragment including "#"
            fragment = uri[hashPosition:]
            # The full uri before the fragment
            uri = uri[:hashPosition]
        if uri.contains('?'):
            uri += '&'
        else:
            uri += '?'
        uri += extraParams
        if fragment is not None:
            uri += fragment
        return uri
